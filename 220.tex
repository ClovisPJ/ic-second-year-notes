\documentclass[twocolumn,english]{article}
\usepackage[latin9]{inputenc}
\usepackage[landscape]{geometry}
\geometry{verbose,tmargin=0.5in,bmargin=0.75in,lmargin=0.5in,rmargin=0.5in}
\setlength{\parskip}{0bp}
\setlength{\parindent}{0pt}
\usepackage{float}
\usepackage{graphicx}

\makeatletter



\usepackage{array}
\usepackage{multirow}
\usepackage{amsbsy}




\providecommand{\tabularnewline}{\\}

\setlength{\columnsep}{0.25in}
\usepackage{xcolor}
\usepackage{textcomp}
\usepackage{listings}
\lstset{
  tabsize=2,
  basicstyle=\small\ttfamily,
}



\usepackage{babel}
\usepackage{listings}
\renewcommand{\lstlistingname}{Listing}

\makeatother

\usepackage{babel}
\usepackage{listings}
\renewcommand{\lstlistingname}{Listing}

\begin{document}

\title{Reference Sheet for C220 Software Engineering Design}

\date{Autumn 2017}
\maketitle

\section{Test-Driven Development}

\paragraph{Four Elements of Simple Design}

In order of importance:
\begin{enumerate}
\item Behaves correctly.
\item Minimises duplication.
\item Maximises clarity.
\item Has fewer elements.
\end{enumerate}

\paragraph{TDD Cycle}
\begin{enumerate}
\item Write a failing test (API design).
\item Code to pass test (internals design).
\item Refactor (structural design).
\end{enumerate}

\paragraph{Refactoring}

Process of improving the design of a piece of code, without changing
its functionality.
\begin{itemize}
\item Should be applied \emph{little and often} to continuously improve
design.
\item Only refactor in a \emph{green state}. Tests ensure that behaviour
is preserved.
\item Should be \emph{automated} to be done quickly and reliably.
\item Small transformations are \emph{combined} to achieve larger refactorings.
\end{itemize}

\paragraph{Example Transformations}
\begin{enumerate}
\item \emph{Compose (extract) method}: Break down method into chunks to
make it shorter. Allows us to give a name for a concept and increase
level of abstraction. Try to keep a constant level of abstraction.
\item \emph{Inline variable}: Instead of using a temporary variable, inline
its usages. Reduces number of elements in method.
\item \emph{Extract to common class}: First work to make duplication exactly
the same. Then refactor it, e.g. to another object. Reduces duplication.
\end{enumerate}

\paragraph{Technical Debt}

Features are been added quickly, in an inelegant way. When not fixed
quickly, \emph{technical debt} builds up.

\section{Mock Objects}

\subsubsection*{UML Sequence Diagrams}

\begin{figure}[H]
\centering{}\includegraphics[width=0.5\columnwidth]{img/uml}
\end{figure}

\subsubsection*{Mock Objects}

\begin{lstlisting}[language=Java,basicstyle={\footnotesize\ttfamily}]
public class TestObjectTest {
  // Set up mockery
  @Rule public JUnityRuleMockery context = new JUnitRuleMockery();

  // Set up test constants
  final Order EXAMPLE_PARAM = new ...;
  ...

  // Set up mock objects
  CalledObject calledObject = context.mock(CalledObject.class);
  ...

  // Set up object to test
  TestObject testObject = new TestObject(calledObject, ...)

  @Test
  public void doesSomethingSpecific() {
    // Set up exceptions / return values
    SomeException exception = new SomeException();

    // Set up expectations
    context.checking(new Expectations() {{
      // Ignore: ignoring / allowing
      ignoring(unimportantMockObject);
      allowing(someMockObject).someMethod(with(any(ParamType.class)));
                               will(throwException(exception));

      // Expect: exactly(n) / atLeast(n) / atMost(n)
      exactly(1).of(anotherMockObject).someOtherMethod(exception);
      exactly(1).of(anotherMockObject).anotherMethod(EXAMPLE_PARAM);
                                       will(returnValue(x));

      // Don't expect: never
      never(aDifferentMockObject).aDifferentMethod();
    }});
    
    // Set up triggers
    testObject.testedMethod(EXAMPLE_PARAM, ...);
    testObject.anotherTestedMethod();

    // Make assertions
    assertThat(testObject.getSomeValue(), is(x));
  }
\end{lstlisting}

\section{Tell Don't Ask}

\paragraph{Commands vs. Queries}
\begin{itemize}
\item \emph{Commands}:\emph{ Ask another object to do something for us}.
Don't care how it's done, don't expect return value. Changes state
of invoked object.
\item \emph{Queries}:\emph{ Ask another object to tell us a value} (so we
can do something with it). Should return value, but not have side
effects on state of invoked object.
\end{itemize}

\paragraph{Law of Demeter}

\emph{Only talk to your immediate friends}. Implementations that depend
on pieces of the system further away result in tight coupling.
\begin{itemize}
\item \emph{Fragility}: when we change one part, other parts break unexpectedly.
\item \emph{Immobility}: it is hard to reuse elements of the code in other
applications.
\end{itemize}

\paragraph{Tell Don't Ask}

Objects send messages, requesting actions, but do not expect return
values. Only queries return values.
\end{document}
